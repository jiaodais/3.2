#include "LPC11xx.h"   // Device header
#include "UART.h"
#include <stdio.h>
#include <string.h>
#include "delay.h"
//#define int temperature[111]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
//														   21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,
//					                     41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,
//					                     61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
//                          		 81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,
//					                      101,102,103,104,105,106,107,108,109,110		};
					char    GcRcvBuf [20];//ADC数据缓冲区
				  int  NTC_Tem_PR[111]={  28017,26825,25697,24629,23617,22659,21752,20891,20074,19298,//0---9C的阻值
																	     18560,18481,18148,17631,16991,16279,15535,14786,14055,13353,//10-19C的阻值
																	     12690,12068,11490,10953,10458,10000, 9576, 9183, 8818, 8478,//20-29C的阻值
																	      8160, 7860, 7578, 7310, 7056, 6813, 6580, 6357, 6141, 5934,//30-39C的阻值
																		    5734, 5540, 5353, 5172, 4997, 4828, 4665, 4507, 4354, 4207,//40-49C的阻值
																		    4065, 3927, 3793, 3663, 3537, 3414, 3293, 3175, 3057, 2941,//50-59C的阻值
																		    2825, 2776, 2717, 2652, 2581, 2507, 2431, 2355, 2280, 2206,//60-69C的阻值
																		    2135, 2066, 2000, 1937, 1878, 1822, 1769, 1719, 1672, 1628,//70-79C的阻值
																		    1586, 1545, 1507, 1470, 1435, 1400, 1366, 1333, 1300, 1268,//80-89C的阻值
																		    1236, 1203, 1171, 1139, 1106, 1074, 1042, 1010,  978,  948,//90-99C的阻值
					                               918,  888,  861,  834,  809,  787,  766,  748,  733,  721,//100-109的阻值
					                               713};//110的阻值
				int	temperature[111]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
														   21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,
					                     41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,
					                     61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
                          		 81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,
					                      101,102,103,104,105,106,107,108,109,110		};
					
				 long double NTC_Tem_NR[40]={53176.6,30602.8,32003.5,33480.2,35036.2,36674.6,38398.8,40212.1,42118.0,44120.1,//-1~-10 
																	 46222.4,48429.4,50745.6,53176.6,55728.4,58408.0,61223.3,64183.4,67298.7,70581.1,//-11~-20
				                           74044.2,77703.1,81574.7,85677.8,90032.6,94660.8,99584.7,104827.2,110409.8,116351.9,//-21~-30
																	122667.8,129364.1,136436.1,143862.4,151597.5,159564.7,167646.7,175674.0,183413.2,190556.2};//-31~-40			
				uint32_t ulADCBuf;
			  uint32_t ulADCData;
				uint32_t t;
					float temp;
				

void ADC_Init(void)
{
	LPC_SYSCON ->SYSAHBCLKCTRL|=(1<<16);
	LPC_IOCON ->PIO1_11 &=~0XBF;//配置PIO1_11为模拟输入模式
	LPC_IOCON ->PIO1_11 |=0X01;//P1.11模拟输入通道7
	LPC_SYSCON->PDRUNCFG &=~(0X01<<4);//ADC模块上电
	LPC_SYSCON ->SYSAHBCLKCTRL |=(0X01<<13);//使能ADC模块时钟
	LPC_ADC ->CR = (0X01<<7)|//SEL=7，选择ADC即ADC7
	               ((SystemCoreClock /1000000-1)<<8)|//转换时钟1M
								 (0<<16)|//软件控制转换操作
								 (0<<17)|//使用1clocks转换
								 (0<<24)|//ADC转换停止
								 (0<<27);//直接启动ADC转换，此位无效

}

float   CaculTwoPoint(float   x1, float y1, float x2, float y2, float x)
{
    return y1 + ((float )(y2 - y1) * (x - x1)) / (x2 - x1);
}

float  ADC_read()
{

	uint32_t tempBuf1;
	uint32_t tempBuf2;

	
	for(t=0;t<10;t++)
	{
		LPC_ADC ->CR |=(1<<24);//立即转换
		while((LPC_ADC->DR[7]&0X80000000)==0);//读取DR0的Done
		LPC_ADC ->CR |=(1<<24);//第一次丢弃
		while((LPC_ADC->DR[7]&0X80000000)==0);//读取DR0的Done
		ulADCBuf=LPC_ADC->DR[7];//读取结果寄存器
		ulADCBuf=(ulADCBuf>>6)&0x3ff;//数据 从第六位开始存储，占据10位
		ulADCData+=ulADCBuf;//数据累加
	}
	  ulADCData=ulADCData/10;//采样10次进行滤波
		ulADCData=(ulADCData*3300)/1024;//数字量转换成模拟量
	
		ulADCData=(ulADCData*10000)/(3300-ulADCData);//求R
//-----------------------------------------------------------------------------------------------------------------------------------
	if(ulADCData<=NTC_Tem_PR[0])///判断温度是否为正
	{
			 for(t=0;t<111;t++)
			{
				if(ulADCData>NTC_Tem_PR[t]&&ulADCData<NTC_Tem_PR[t-1])//判断根据阻值此时温度
				{
					tempBuf1 = temperature [t-1];
					tempBuf2 = temperature [t];
					break ;
					
				}
		}
		 temp=CaculTwoPoint(NTC_Tem_PR[t-1],temperature [t-1] ,NTC_Tem_PR[t],temperature [t],ulADCData);//利用两点公式计算温度
	   sprintf (GcRcvBuf ,"temperature=%4f C\r\n", temp  );//将数据发送到串口进行显示
			   
	}	
//----------------------------------------------------------------------------------------------------------------------------------
			else 
			{
      for(t=0;t>40;t++)
	      {
					if(ulADCData<NTC_Tem_NR[t]&&ulADCData>NTC_Tem_NR[t+1])//温度为负时
					{
						tempBuf1 =t;
						tempBuf2=t+1;
						break;
					}
	      }
					temp=CaculTwoPoint(NTC_Tem_NR[t],t ,NTC_Tem_NR[t+1],t+1,ulADCData);
				  sprintf (GcRcvBuf ,"temperature=-%4fC\r\n",temp );//将数据发送到串口进行显示
					
      }	
//--------------------------------------------------------------------------------------------------------------------------------
	if(ulADCData !=0)
	{
		UART_SendStr(GcRcvBuf );//将数据发送到串口显示	
	
		return temp;
	
	}	
		
		
		delay (50);//刷新
//--------------------------------------------------------------------------------------------------------------------------------
}
		



















